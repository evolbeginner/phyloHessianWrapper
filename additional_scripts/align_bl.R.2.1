#! /usr/bin/env Rscript

##################################
# Load necessary libraries quietly
suppressPackageStartupMessages(
  suppressWarnings({
    library(phytools)
    library(phangorn)
  })
)

##################################
# Parse command line arguments
args <- commandArgs(trailingOnly = T)

if (length(args) < 2) {
  stop("Usage: Rscript script.R <tree_file> <branch_definition_file>")
}

treefile <- args[1]
branch_out_infile <- args[2]

# Read tree(s). Standardize to a list even if single tree.
trees_in <- read.tree(treefile)
if (inherits(trees_in, "phylo")) {
  trees <- list(trees_in)
} else {
  trees <- trees_in
}

# Read the master branch definition table once
# Expected format: Column 1 = branch split string, Column 2 = branch length (or dummy)
df_master <- read.table(branch_out_infile, header = F, stringsAsFactors = FALSE)
colnames(df_master) <- c('branch', 'bl')
df_master$tree_order <- seq_len(nrow(df_master))

# Helper sort function for consistent string matching
new_sort <- function(v){
  v[order(tolower(v), method='radix')]
}

##################################
# Loop through each tree
for(t_idx in 1:length(trees)){
  
  phy <- trees[[t_idx]]
  
  # We need a fresh copy of the master dataframe for calculation
  df <- df_master
  
  nb.tip <- length(phy$tip.label)
  
  # Pre-calculate descendants for ALL nodes (tips and internal) at once.
  # This returns a LIST where index 'i' corresponds to node 'i'.
  # This is much faster and safer than calling Descendants inside the loop.
  all_descendants <- Descendants(phy, type = "tips")
  
  # 1. Extract all splits/branches from the current tree 'phy'
  #    and store them in a vector 'current_tree_splits' indexed by ape's edge order.
  
  current_tree_splits <- character(nrow(phy$edge))
  
  # Loop through edges to build the split string for each edge
  for(i in 1:nrow(phy$edge)){
    node_idx <- phy$edge[i, 2] # The descendant node defines the split
    
    # Extract the vector of tip indices from our pre-calculated list
    # We use [[ ]] to ensure we get the vector, not a sub-list
    tips_indices <- all_descendants[[node_idx]]
    
    tip_names <- new_sort(phy$tip.label[tips_indices])
    
    # Form the two sides of the split
    side1 <- paste(tip_names, collapse='-')
    
    # The other side is all tips NOT in the descendant group
    comp_tips_indices <- setdiff(1:nb.tip, tips_indices)
    comp_tip_names <- new_sort(phy$tip.label[comp_tips_indices])
    side2 <- paste(comp_tip_names, collapse='-')
    
    # Combine into the standard format: "side1,side2" (sorted)
    full_split <- paste(new_sort(c(side1, side2)), collapse=',')
    current_tree_splits[i] <- full_split
  }
  
  # 2. Map the input file's branches to the current tree's edges
  
  # Find which edge index matches the branch string in df
  edge_indices <- sapply(df$branch, function(b) {
    # Handle potential reversal of the comma separation
    parts <- unlist(strsplit(b, ","))
    alt_b <- paste(rev(parts), collapse=",")
    
    match_idx <- which(current_tree_splits == b | current_tree_splits == alt_b)
    
    if(length(match_idx) > 0) return(match_idx[1]) else return(NA)
  })
  
  df$ape_order <- edge_indices
  
  # Extract the actual branch length from the current tree using the found edge index
  current_bls <- sapply(edge_indices, function(idx) {
    if(is.na(idx)) return(0.0) else return(phy$edge.length[idx])
  })
  
  # Update the 'bl' column with the ACTUAL lengths from this specific tree
  df$bl <- current_bls
  
  # 3. OUTPUTS
  
  # A) The Table: Output ONLY for the first tree (t_idx == 1)
  if(t_idx == 1){
    write.table(df[, c("branch", "bl", "tree_order", "ape_order")], 
                sep="\t", quote=F, row.names=F, col.names=T)
  }
  
  # B) The Branch Lengths: Output for EVERY tree
  #    SORT the dataframe by 'ape_order' before printing the string
  
  # Note: If a branch is not found (NA), it will be placed at the end by default.
  #df_sorted <- df[order(df$ape_order), ]
  df_sorted <- df[order(df$tree_order), ]
  
  cat(paste(df_sorted$bl, collapse=','))
  cat("\n")
}

